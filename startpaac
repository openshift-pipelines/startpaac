#!/usr/bin/env bash
# Copyright 2024 Chmouel Boudjnah <chmouel@chmouel.com>
# shellcheck disable=SC2046,SC1091
set -eufo pipefail

scale_down_controller=""

Miself=$(readlink -f "$0")
SP=$(dirname "${Miself}")
source "${SP}/lib/common.sh"
source "${SP}/lib/config.sh"

PAC_CONTROLLER_TARGET_NS=pipelines-as-code
_git_root=$(git rev-parse --show-toplevel 2>/dev/null || echo "")
if [[ -d ${_git_root}/config ]]; then
  PAC_DIR=${_git_root}
else
  [[ -z ${PAC_DIR:-""} ]] && {
    echo "You really need to set the PAC_DIR variable in your ${CONFIG_FILE}"
    exit 1
  }

  cd "${PAC_DIR:-}" || {
    echo "cannot find the pipelines-as-code directory, set the PAC_DIR variable to where you have checked out the github.com/openshift-pipelines/pipelines-as-code repository in your ${HOME}/.config/startpaac/config"
    exit 1
  }
fi

# Note: check_tools() is called later after argument parsing to respect CI_MODE flag

[[ -n "$*" && "${*}" == *\ local ]] && TARGET_HOST=local

TARGET_HOST=${TARGET_HOST:-}
DOMAIN_NAME=${DOMAIN_NAME:-""}
PAAC_DOMAIN=${PAAC_DOMAIN:-""}
PAAC=${PAAC:-""}
REGISTRY=${REGISTRY:-""}
KO_EXTRA_FLAGS=${KO_EXTRA_FLAGS:-""}
FORGE_HOST=${FORGE_HOST:-""}
INSTALL_GITHUB_SECOND_CTRL=${INSTALL_GITHUB_SECOND_CTRL:-""}
INSTALL_FORGE=${INSTALL_FORGE:-"true"}
PAC_PASS_SECOND_FOLDER=${PAC_PASS_SECOND_FOLDER:-}
PAC_DEBUG_IMAGE=${PAC_DEBUG_IMAGE:-registry.access.redhat.com/ubi9/ubi-minimal}
PAC_IMAGE_NONROOT=${PAC_IMAGE_NONROOT:-"true"}

# Component installation preferences
PREFERENCES_FILE="${HOME}/.config/startpaac/preferences.json"
INSTALL_PAC=${INSTALL_PAC:-"true"}
INSTALL_TEKTON_TRIGGERS=${INSTALL_TEKTON_TRIGGERS:-"false"}
INSTALL_TEKTON_CHAINS=${INSTALL_TEKTON_CHAINS:-"false"}
INSTALL_TEKTON_DASHBOARD=${INSTALL_TEKTON_DASHBOARD:-"true"}
INSTALL_POSTGRESQL=${INSTALL_POSTGRESQL:-"false"}
INSTALL_CUSTOM_OBJECT_ENABLED=${INSTALL_CUSTOM_OBJECT_ENABLED:-"false"}
FORCE_INTERACTIVE=${FORCE_INTERACTIVE:-"false"}

# CI mode settings
CI_MODE=${CI_MODE:-"false"}
export CI_MODE

if [[ ${TARGET_HOST} == local ]]; then
  KO_EXTRA_FLAGS=(--insecure-registry)
  DOMAIN_NAME=${TARGET_HOST}
  # Allow domain override via PAAC_DOMAIN for CI compatibility
  PAAC_DOMAIN=${PAAC_DOMAIN:-"127.0.0.1.nip.io"}
  REGISTRY=registry.${PAAC_DOMAIN}
  FORGE_HOST=gitea.${PAAC_DOMAIN}
  TARGET_BIND_IP=127.0.0.1
  DASHBOARD=dashboard.${PAAC_DOMAIN}
  PAAC=paac.${PAAC_DOMAIN}
fi

[[ -z ${DOMAIN_NAME} || -z ${TARGET_HOST} || -z ${TARGET_BIND_IP} || -z ${REGISTRY} || -z ${DASHBOARD} || -z ${PAAC} ]] && {
  echo "Need to set DOMAIN_NAME, TARGET_HOST, TARGET_BIND_IP, REGISTRY, DASHBOARD and PAAC in your $HOME/.config/startpaac/config"
  exit 1
}
[[ -n ${DOMAIN_NAME} && -z ${PAAC_DOMAIN} ]] && PAAC_DOMAIN=${DOMAIN_NAME}

TMPFILE=$(mktemp /tmp/.startpaac.XXXXXX)
# shellcheck disable=SC2317
clean() { rm -f "${TMPFILE}"; }
trap clean EXIT

export KUBECONFIG=${KUBECONFIG:-$HOME/.kube/config.${DOMAIN_NAME%%.*}}

if [[ -z ${TARGET_HOST} ]] || [[ -z ${DOMAIN_NAME} ]] || [[ -z ${REGISTRY} ]] || [[ -z ${KUBECONFIG} ]]; then
  echo "Need env variable TARGET_HOST, DOMAIN_NAME and REGISTRY"
  exit 1
fi

show_config() {
  local smee_url protocol
  if [[ -n ${PAC_PASS_SECRET_FOLDER:-""} ]]; then
    smee_url=$(pass show ${PAC_PASS_SECRET_FOLDER}/smee)
  elif [[ -n ${PAC_SECRET_FOLDER:-""} ]]; then
    smee_url=$(cat ${PAC_SECRET_FOLDER}/smee)
  fi
  protocol="https"
  cat <<EOF
Using configuration on ${TARGET_HOST}:

DOMAIN_NAME: ${DOMAIN_NAME},
TARGET_BIND_IP: ${TARGET_BIND_IP}
PAAC: ${protocol}://${PAAC}
REGISTRY: ${protocol}://${REGISTRY}
FORGE_HOST: ${protocol}://${FORGE_HOST}
DASHBOARD: ${protocol}://${DASHBOARD}
  GOSMEE:
  gosmee client --saveDir /tmp/replay ${smee_url} ${protocol}://${PAAC}
EOF
}

cache_yaml_file() {
  local type="$1"
  local url="$2"
  local cache_dir="${HOME}/.cache/startpaac"
  local filename="${cache_dir}/${type}.yaml"
  mkdir -p "${cache_dir}"

  if [[ ! -e "${filename}" ]]; then
    curl --progress-bar -L --location --retry 10 --retry-max-time 10 -o "${filename}" "${url}"
  fi
  echo "${filename}"
}

check_kind() {
  output=$(ssh -q "${TARGET_HOST}" which kind || true)
  if [[ "${output}" == *"not found" ]]; then
    echo "Kind is not installed on ${TARGET_HOST}"
    exit 1
  fi
}

install_kind() {
  [[ "${TARGET_HOST}" != local ]] && check_kind
  stop_kind
  show_step "Creating kind cluster"
  local kfilename="${SP}/lib/kind/kind.yaml"

  # Split TARGET_BIND_IP by comma to support multiple IPs
  IFS=',' read -ra BIND_IPS <<<"${TARGET_BIND_IP}"

  # Trim whitespace from each IP
  for i in "${!BIND_IPS[@]}"; do
    BIND_IPS[$i]=$(echo "${BIND_IPS[$i]}" | xargs)
  done

  local primary_ip="${BIND_IPS[0]}"

  # Start with the base template, replacing registry and primary IP
  sed -e "s/%REGISTRY%/${REGISTRY}/" -e "s/%TARGET_BIND_IP%/${primary_ip}/" "${kfilename}" >"${TMPFILE}"

  # If there are multiple IPs, add additional port mappings
  if [[ ${#BIND_IPS[@]} -gt 1 ]]; then
    # Create a temporary file for the extra port mappings
    local extra_mappings
    extra_mappings=$(mktemp)
    for ip in "${BIND_IPS[@]:1}"; do
      cat >>"${extra_mappings}" <<EOF
      - containerPort: 80
        hostPort: 80
        listenAddress: "${ip}"
        protocol: TCP
      - containerPort: 443
        hostPort: 443
        listenAddress: "${ip}"
        protocol: TCP
      - containerPort: 32567
        hostPort: 3000
        listenAddress: "${ip}"
        protocol: TCP
EOF
    done

    # Insert the extra mappings before the containerdConfigPatches section
    # Use gawk if available (macOS ships with BSD awk which is limited)
    local awk_cmd="awk"
    if command -v gawk >/dev/null 2>&1; then
      awk_cmd="gawk"
    fi

    "${awk_cmd}" -v extra="$(cat "${extra_mappings}")" '
      /^containerdConfigPatches:/ {
        if (!inserted) {
          print extra;
          inserted=1
        }
        print;
        next
      }
      {print}
    ' "${TMPFILE}" >"${TMPFILE}.new"
    mv "${TMPFILE}.new" "${TMPFILE}"
    rm -f "${extra_mappings}"
  fi
  case ${TARGET_HOST} in
  local)
    kind create cluster --kubeconfig "${KUBECONFIG}" --config "${TMPFILE}"
    ;;
  *)
    scp -q "${TMPFILE}" "${TARGET_HOST}":/tmp/.kind.yaml
    ssh -q "${TARGET_HOST}" kind create cluster --kubeconfig ".kube/$(basename "${KUBECONFIG}")" --config /tmp/.kind.yaml
    ;;
  esac
}

install_nginx() {
  local release_yaml
  show_step "Installing nginx ingress"
  release_yaml=$(cache_yaml_file nginx https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml)
  kubectl apply -f "${release_yaml}" >/dev/null
  kubectl -n ingress-nginx annotate ingressclasses nginx ingressclass.kubernetes.io/is-default-class="true" --overwrite=true
  wait_for_resource endpoint ingress-nginx ingress-nginx-controller
}

install_registry() {
  show_step "Installing registry"
  "${SP}"/lib/registry/install.sh ${REGISTRY} ${TARGET_HOST}
}

install_tekton() {
  local release_yaml
  show_step "Deploying Tekton"
  release_yaml=$(cache_yaml_file tekton https://storage.googleapis.com/tekton-releases/pipeline/latest/release.yaml)
  kubectl apply --filename "${release_yaml}" >/dev/null
  wait_for_resource endpoint tekton-pipelines tekton-pipelines-webhook
  kubectl patch configmap -n tekton-pipelines --type merge -p '{"data":{"enable-step-actions": "true"}}' feature-flags
}

install_triggers() {
  local release_yaml
  show_step "Deploying Tekton Triggers"
  release_yaml=$(cache_yaml_file tekton-triggers https://storage.googleapis.com/tekton-releases/triggers/latest/release.yaml)
  kubectl apply --filename "${release_yaml}" >/dev/null
  wait_for_resource endpoint tekton-pipelines tekton-triggers-webhook
}

install_chains() {
  local release_yaml
  show_step "Deploying Tekton Chains"
  release_yaml=$(cache_yaml_file tekton-chains https://storage.googleapis.com/tekton-releases/chains/latest/release.yaml)
  kubectl apply --filename "${release_yaml}" >/dev/null
  wait_for_resource deployment tekton-chains tekton-chains-controller
}

install_dashboard() {
  local release_yaml
  show_step "Deploying Tekton Dashboard"
  release_yaml=$(cache_yaml_file dashboard https://storage.googleapis.com/tekton-releases/dashboard/latest/release.yaml)
  kubectl apply --filename "${release_yaml}" >/dev/null
  create_ingress tekton-pipelines tekton-dashboard ${DASHBOARD} 9097
}

stop_kind() {
  show_step "Stopping Kind"

  case ${TARGET_HOST} in
  local)
    kind delete cluster --name kind
    ;;
  *)
    ssh -q "${TARGET_HOST}" kind delete cluster --name kind
    ;;
  esac
  rm -f "${KUBECONFIG}"
}

install_pac() {
  tmppac=$(mktemp /tmp/.pac.config.XXXXXX)
  # shellcheck disable=SC2317
  __clean() { rm -f "${tmppac}"; }
  trap __clean EXIT

  if [[ -n ${1:-""} ]]; then
    show_step "Deploying PAC $1"
  else
    show_step "Deploying PAC"
  fi
  local c=config
  case ${1:-""} in
  controller)
    c=${c}/400-controller.yaml
    ;;
  watcher)
    c=${c}/500-watcher.yaml
    ;;
  webhook)
    c=${c}/600-webhook.yaml
    ;;
  esac
  extras=()
  [[ -e "${PAC_DIR}/pkg/test/nonoai/deployment.yaml" ]] && extras+=(-f "${PAC_DIR}/pkg/test/nonoai/deployment.yaml")
  env KO_DOCKER_REPO="${REGISTRY}" ko resolve -f"${c}" "${extras[@]}" -B --sbom=none "${KO_EXTRA_FLAGS[@]}" >"${tmppac}"
  if [[ -n ${PAC_IMAGE_NONROOT} && "${PAC_IMAGE_NONROOT}" == false ]]; then
    sed -i 's/^\(\s*runAsNonRoot:\) true/\1 false/' "${tmppac}"
  fi
  kubectl apply -f "${tmppac}"
  echo "Using config from: ${c}"

  for controller in ${scale_down_controller}; do
    kubectl scale deployment -n pipelines-as-code -l "app.kubernetes.io/name=${controller}" --replicas=0
  done
}

create_pac_secret() {
  folder=$1
  shift
  secret_name=$1
  shift
  target_ns=${1}
  shift
  read -r -a read_method <<<"$@"

  kubectl delete secret "${secret_name}" -n "${target_ns}" 2>/dev/null || true
  kubectl create secret generic "${secret_name}" -n "${target_ns}"
  for passk in github-application-id github-private-key webhook.secret; do
    if [[ ${passk} == *-key ]]; then
      b64d=$("${read_method[@]}" "${folder}/${passk}" | base64 -w0)
    else
      b64d=$(echo -n "$("${read_method[@]}" "${folder}/${passk}")" | base64 -w0)
    fi
    kubectl patch secret -n "${target_ns}" -p "{\"data\":{\"${passk}\": \"${b64d}\"}}" \
      --type merge "${secret_name}" >/dev/null
  done
}

patch_configmap() {
  local target_ns=${1:-pipelines-as-code}
  local configmap=${2:-pipelines-as-code}
  local kind_url="http://${DASHBOARD}"
  kubectl patch configmap -n "${target_ns}" -p \
    "{\"data\":{\"bitbucket-cloud-check-source-ip\": \"false\"}}" \
    --type merge "${configmap}"

  kubectl patch configmap -n "${target_ns}" -p \
    "{\"data\":{\"tekton-dashboard-url\": \"${kind_url}\"}}" \
    --type merge "${configmap}"

  kubectl patch configmap pac-config-logging -n "${target_ns}" \
    --type json -p '[{"op": "replace", "path": "/data/loglevel.pipelinesascode", "value":"debug"}]'
}

configure_pac() {
  local pac_controller_secret=pipelines-as-code-secret no_ingress=
  show_step "Configuring PAC"
  [[ -n ${1:-} && ${1} == "--no-ingress" ]] && no_ingress=yes
  if [[ -z ${no_ingress} ]]; then
    create_ingress pipelines-as-code pipelines-as-code-controller "${PAAC}" 8080
  fi
  patch_configmap "${PAC_CONTROLLER_TARGET_NS}"

  if [[ -n ${PAC_PASS_SECRET_FOLDER:-} ]]; then
    echo "Installing PAC secrets from pass folder: ${PAC_PASS_SECRET_FOLDER}"
    create_pac_secret "${PAC_PASS_SECRET_FOLDER}" "${pac_controller_secret}" "${PAC_CONTROLLER_TARGET_NS}" pass show
  elif [[ -n ${PAC_SECRET_FOLDER:-} ]]; then
    echo "Installing PAC secrets from plain text folder: ${PAC_SECRET_FOLDER}"
    create_pac_secret "${PAC_SECRET_FOLDER}" "${pac_controller_secret}" "${PAC_CONTROLLER_TARGET_NS}" cat
  else
    cat <<EOF
  **No secret has been installed**

  You need to either create a pass https://www.passwordstore.org/ folder with
  github-application-id github-private-key webhook.secret information in there
  and export the PAC_PASS_SECRET_FOLDER variable to that folder

  Or have a plain text folder with the same structure and export the
  PAC_SECRET_FOLDER variable

  Or have nothing and install the secrets manually after running the startpaac
  script.
EOF
    kubectl delete secret -n pipelines-as-code pipelines-as-code-secret >/dev/null 2>/dev/null || true
  fi
}

function install_forgejo() {
  show_step "Installing Forgejo"
  "${SP}"/lib/forgejo/install.sh ${1}
}

function install_postgresql() {
  show_step "Installing PostgreSQL"
  "${SP}"/lib/postgresql/install.sh
}

function sync_kubeconfig() {
  [[ ${TARGET_HOST} == local ]] && return
  show_step "Syncing kubeconfig"
  scp -q "${TARGET_HOST}":.kube/$(basename ${KUBECONFIG}) "${KUBECONFIG}"
  echo "${KUBECONFIG} from ${TARGET_HOST} has been updated"
  chmod 600 "${KUBECONFIG}"
  set_namespace pipelines-as-code
}

function start_user_gosmee() {
  local service=${1:-"gosmee"}
  local smeeurl=${2:-}
  local controllerURL=${3:-}
  local protocol="https"
  type -p systemctl >/dev/null 2>/dev/null && return
  [[ -e ${HOME}/.config/systemd/user/${service}.service ]] || {
    if [[ -n ${smeeurl} ]]; then
      show_step "Run gosmee manually"
      echo "gosmee client --saveDir /tmp/replay ${smeeurl} ${protocol}://${controllerURL}"
    else
      echo "Skipping running gosmee: cannot find ${HOME}/.config/systemd/user/${service}.service"
    fi
    return
  }
  show_step "Running ${service} systemd service locally for user $USER"
  systemctl --user restart ${service} >/dev/null 2>&1 || true
  systemctl --user status ${service} -o cat
  if kubectl get deployment gosmee-ghe -n "${PAC_CONTROLLER_TARGET_NS}" >/dev/null 2>&1; then
    kubectl scale deployment gosmee-ghe -n "${PAC_CONTROLLER_TARGET_NS}" --replicas=0 >/dev/null || true
    echo "Deployment $(echo_color red gosmee-ghe) has been scaled down"
  fi
}

function install_github_second_ctrl() {
  local pac_controller_label="ghe" pac_controller_smee_url
  local pac_controller_secret=${pac_controller_label}-secret
  local pac_controller_configmap=${pac_controller_label}-configmap
  local gosmeeTargetURL=${pac_controller_label}.${PAAC_DOMAIN}
  show_step "Installing GHE second controller for github"

  [[ -z ${PAC_PASS_SECOND_FOLDER:-} && -z ${PAC_SECOND_SECRET_FOLDER:-} ]] && {
    echo "You need to set the PAC_PASS_SECOND_FOLDER or PAC_SECOND_SECRET_FOLDER variables in your ${CONFIG_FILE}"
    exit 1
  }
  if [[ -n ${PAC_PASS_SECOND_FOLDER} ]]; then
    local password_store_path=${PASSWORD_STORE_DIR:-$HOME/.password-store}
    [[ -d ${password_store_path}/${PAC_PASS_SECOND_FOLDER} ]] || {
      echo "secondSecret ${PAC_PASS_SECOND_FOLDER} does not exist"
      echo "set environment variable PAC_PASS_SECOND_FOLDER to the correct pass folder"
      exit 1
    }
    echo "Using pass_secret_folder: ${PAC_PASS_SECOND_FOLDER}"
    pac_controller_smee_url=$(pass show ${PAC_PASS_SECOND_FOLDER} | sed -n '/SMEE_URL/ { s/.*=//;p}')
  elif [[ -n ${PAC_SECOND_SECRET_FOLDER} ]]; then
    if [[ ! -d ${PAC_SECOND_SECRET_FOLDER} ]]; then
      echo "folder for second secret ${PAC_SECOND_SECRET_FOLDER} does not exist"
      echo "set environment variable PAC_SECOND_SECRET_FOLDER to the correct folder with all your environment secrets"
      exit 1
    fi
    echo "Using secret_folder: ${PAC_SECOND_SECRET_FOLDER}"
    pac_controller_smee_url=$(cat ${PAC_SECOND_SECRET_FOLDER}/smee)
  fi

  type -p uv 2>/dev/null || {
    echo "Installing uv tool to generate second controller yaml"
    curl -LsSf https://astral.sh/uv/install.sh | sh
  }
  env PAC_CONTROLLER_LABEL=${pac_controller_label} \
    PAC_CONTROLLER_SECRET=${pac_controller_secret} \
    PAC_CONTROLLER_CONFIGMAP=${pac_controller_configmap} \
    PAC_CONTROLLER_TARGET_NS=${PAC_CONTROLLER_TARGET_NS} \
    PAC_CONTROLLER_IMAGE="ko" \
    hack/second-controller.py ${pac_controller_label} |
    tee /tmp/.second.controller.debug.yaml |
    env KO_DOCKER_REPO="${REGISTRY}" ko apply -f- -B --sbom=none "${KO_EXTRA_FLAGS[@]}"
  patch_configmap ${PAC_CONTROLLER_TARGET_NS} ${pac_controller_configmap}
  kubectl delete secret ${pac_controller_secret} -n ${PAC_CONTROLLER_TARGET_NS} >/dev/null 2>/dev/null || true
  kubectl create secret generic ${pac_controller_secret} -n ${PAC_CONTROLLER_TARGET_NS} >/dev/null
  if [[ -n ${PAC_PASS_SECOND_FOLDER} ]]; then
    echo "Installing PAC secrets from pass folder: ${PAC_PASS_SECRET_FOLDER}"
    create_pac_secret ${PAC_PASS_SECOND_FOLDER} ${pac_controller_secret} ${PAC_CONTROLLER_TARGET_NS} pass show
  elif [[ -n ${PAC_SECOND_SECRET_FOLDER} ]]; then
    echo "Installing PAC secrets from plain text folder: ${PAC_SECOND_SECRET_FOLDER}"
    create_pac_secret ${PAC_SECOND_SECRET_FOLDER} ${pac_controller_secret} ${PAC_CONTROLLER_TARGET_NS} cat
  else
    cat <<EOF
No secret has been installed.

You need to either create a pass https://www.passwordstore.org/ folder with github-application-id
github-private-key webhook.secret information in there and export the PAC_PASS_SECOND_FOLDER variable
to that folder

Or have a plain text folder with the same structure and export the PAC_SECOND_SECRET_FOLDER variable"

Or have nothing and install the secrets manually after running the startpaac script.
EOF
  fi

  show_step "Creating ingress for ${pac_controller_label} controller"
  create_ingress ${PAC_CONTROLLER_TARGET_NS} ${pac_controller_label}-controller "${gosmeeTargetURL}" 8080
  (kubectl delete deployment -n ${PAC_CONTROLLER_TARGET_NS} gosmee-${pac_controller_label} 2>&1 | grep -v "not found") || true
  if [[ ${CI_MODE} != "true" ]]; then
    start_user_gosmee ghe ${pac_controller_smee_url} "${gosmeeTargetURL}"
  fi
}

function install_custom_objects() {
  show_step "Installing custom Objects"
  [[ -d ${INSTALL_CUSTOM_OBJECT} ]] || {
    echo "Cannot find ${INSTALL_CUSTOM_OBJECT} directory"
    exit 1
  }
  kubectl apply -f "${INSTALL_CUSTOM_OBJECT}"
}

function set_namespace() {
  local ns=${1:-"default"}
  kubectl config set-context --current --namespace=${ns}
}

all() {
  sync_kubeconfig
  install_nginx
  install_registry
  install_tekton

  # Optional Tekton components
  [[ ${INSTALL_TEKTON_TRIGGERS} == "true" ]] && install_triggers
  [[ ${INSTALL_TEKTON_CHAINS} == "true" ]] && install_chains
  [[ ${INSTALL_TEKTON_DASHBOARD} == "true" ]] && install_dashboard

  # PAC (optional)
  [[ ${INSTALL_PAC} == "true" ]] && {
    install_pac
    configure_pac
  }

  # Other optional components
  [[ ${INSTALL_FORGE} == "true" ]] && install_forgejo ${FORGE_HOST}
  [[ ${INSTALL_POSTGRESQL} == "true" ]] && install_postgresql
  [[ -n ${INSTALL_CUSTOM_OBJECT:-} && ${INSTALL_CUSTOM_OBJECT_ENABLED} == "true" ]] && install_custom_objects

  # In CI mode, auto-enable second controller if secrets are present
  if [[ ${CI_MODE} == "true" ]] && [[ -n ${PAC_SECOND_SECRET_FOLDER:-} ]] && [[ -e ${PAC_SECOND_SECRET_FOLDER}/github-application-id ]]; then
    INSTALL_GITHUB_SECOND_CTRL=true
  fi
  [[ ${INSTALL_GITHUB_SECOND_CTRL} == "true" ]] && install_github_second_ctrl

  start_user_gosmee gosmee

  show_step "Setting current namespace context to pipelines-as-code"
  set_namespace pipelines-as-code
}

function help() {
  # Define color variables
  local NO_COLOR='\033[0m'
  local BOLD='\033[1m'

  echo -e "${BOLD}program.sh [options]${NO_COLOR}
    "
  grep -E '^\s*-.*\)\s*#' "$Miself" | sed -e 's/^[ ]*//' -e "s/\(.*\)) # /\1 @ /" | column -t -s $'@'
  echo -e "
${BOLD}Author: Chmouel Boudjnah <chmouel@chmouel.com>${NO_COLOR}
    "
}

# Load preferences from JSON file
load_preferences() {
  if [[ -f ${PREFERENCES_FILE} ]]; then
    INSTALL_PAC=$(jq -r '.pac // true' "${PREFERENCES_FILE}")
    INSTALL_TEKTON_TRIGGERS=$(jq -r '.tekton_triggers // false' "${PREFERENCES_FILE}")
    INSTALL_TEKTON_CHAINS=$(jq -r '.tekton_chains // false' "${PREFERENCES_FILE}")
    INSTALL_TEKTON_DASHBOARD=$(jq -r '.tekton_dashboard // true' "${PREFERENCES_FILE}")
    INSTALL_FORGE=$(jq -r '.forgejo // true' "${PREFERENCES_FILE}")
    INSTALL_POSTGRESQL=$(jq -r '.postgresql // false' "${PREFERENCES_FILE}")
    INSTALL_CUSTOM_OBJECT_ENABLED=$(jq -r '.custom_objects // false' "${PREFERENCES_FILE}")
    INSTALL_GITHUB_SECOND_CTRL=$(jq -r '.github_second_ctrl // false' "${PREFERENCES_FILE}")
    return 0
  fi
  return 1
}

# Save preferences to JSON file
save_preferences() {
  mkdir -p "$(dirname "${PREFERENCES_FILE}")"
  jq -n \
    --argjson pac "${INSTALL_PAC:-true}" \
    --argjson triggers "${INSTALL_TEKTON_TRIGGERS:-false}" \
    --argjson chains "${INSTALL_TEKTON_CHAINS:-false}" \
    --argjson dashboard "${INSTALL_TEKTON_DASHBOARD:-true}" \
    --argjson forgejo "${INSTALL_FORGE:-true}" \
    --argjson postgresql "${INSTALL_POSTGRESQL:-false}" \
    --argjson custom_objects "${INSTALL_CUSTOM_OBJECT_ENABLED:-false}" \
    --argjson github_second "${INSTALL_GITHUB_SECOND_CTRL:-false}" \
    '{
      pac: $pac,
      tekton_triggers: $triggers,
      tekton_chains: $chains,
      tekton_dashboard: $dashboard,
      forgejo: $forgejo,
      postgresql: $postgresql,
      custom_objects: $custom_objects,
      github_second_ctrl: $github_second
    }' >"${PREFERENCES_FILE}"
}

# Delete preferences file
reset_preferences() {
  if [[ -f ${PREFERENCES_FILE} ]]; then
    rm -f "${PREFERENCES_FILE}"
    echo_color brightgreen "Preferences have been reset."
  else
    echo "No preferences file found."
  fi
}

# Build the list of menu items
build_component_menu() {
  echo "Pipelines-as-Code (PAC)"
  echo "Tekton Triggers"
  echo "Tekton Chains"
  echo "Tekton Dashboard"
  echo "Forgejo"
  echo "PostgreSQL"
  [[ -n ${INSTALL_CUSTOM_OBJECT:-} ]] && echo "Custom Objects"
  [[ -n ${PAC_PASS_SECOND_FOLDER:-} || -n ${PAC_SECOND_SECRET_FOLDER:-} ]] && echo "GitHub Second Controller"
}

# Get pre-selected items based on current INSTALL_* vars
get_preselected_items() {
  local -a selected=()
  [[ ${INSTALL_PAC} == "true" ]] && selected+=("Pipelines-as-Code (PAC)")
  [[ ${INSTALL_TEKTON_TRIGGERS} == "true" ]] && selected+=("Tekton Triggers")
  [[ ${INSTALL_TEKTON_CHAINS} == "true" ]] && selected+=("Tekton Chains")
  [[ ${INSTALL_TEKTON_DASHBOARD} == "true" ]] && selected+=("Tekton Dashboard")
  [[ ${INSTALL_FORGE} == "true" ]] && selected+=("Forgejo")
  [[ ${INSTALL_POSTGRESQL} == "true" ]] && selected+=("PostgreSQL")
  [[ ${INSTALL_CUSTOM_OBJECT_ENABLED} == "true" ]] && selected+=("Custom Objects")
  [[ ${INSTALL_GITHUB_SECOND_CTRL} == "true" ]] && selected+=("GitHub Second Controller")
  printf '%s\n' "${selected[@]}"
}

# Parse menu selections and set INSTALL_* variables
parse_menu_selections() {
  local selections="$1"

  # Reset all optional install flags to false
  INSTALL_PAC="false"
  INSTALL_TEKTON_TRIGGERS="false"
  INSTALL_TEKTON_CHAINS="false"
  INSTALL_TEKTON_DASHBOARD="false"
  INSTALL_FORGE="false"
  INSTALL_POSTGRESQL="false"
  INSTALL_CUSTOM_OBJECT_ENABLED="false"
  INSTALL_GITHUB_SECOND_CTRL="false"

  # Set flags based on selections
  while IFS= read -r item; do
    case "${item}" in
    "Pipelines-as-Code (PAC)")
      INSTALL_PAC="true"
      ;;
    "Tekton Triggers")
      INSTALL_TEKTON_TRIGGERS="true"
      ;;
    "Tekton Chains")
      INSTALL_TEKTON_CHAINS="true"
      ;;
    "Tekton Dashboard")
      INSTALL_TEKTON_DASHBOARD="true"
      ;;
    "Forgejo")
      INSTALL_FORGE="true"
      ;;
    "PostgreSQL")
      INSTALL_POSTGRESQL="true"
      ;;
    "Custom Objects")
      INSTALL_CUSTOM_OBJECT_ENABLED="true"
      ;;
    "GitHub Second Controller")
      INSTALL_GITHUB_SECOND_CTRL="true"
      ;;
    esac
  done <<<"${selections}"
}

# Display the gum menu and get selections
show_component_menu() {
  local menu_items selected_items preselected

  echo ""
  echo_color brightgreen "Select optional components to install:"
  echo_color yellow "(Core: Kind, Nginx, Registry, Tekton Pipelines are always installed)"
  echo ""

  menu_items=$(build_component_menu)
  preselected=$(get_preselected_items | paste -sd, -)

  if [[ -n ${preselected} ]]; then
    selected_items=$(echo "${menu_items}" | gum choose --no-limit --selected="${preselected}")
  else
    selected_items=$(echo "${menu_items}" | gum choose --no-limit)
  fi

  parse_menu_selections "${selected_items}"
}

# Ask user if they want to save preferences
prompt_save_preferences() {
  echo ""
  if gum confirm "Save these preferences for next time?"; then
    save_preferences
    echo_color brightgreen "Preferences saved to ${PREFERENCES_FILE}"
  fi
}

# Display summary of selected components
show_selected_components() {
  echo ""
  echo_color brightgreen "Components to be installed:"
  echo " - Kind cluster"
  echo " - Nginx ingress"
  echo " - Docker Registry"
  echo " - Tekton Pipelines"

  [[ ${INSTALL_PAC} == "true" ]] && echo " - Pipelines-as-Code (PAC)"
  [[ ${INSTALL_TEKTON_TRIGGERS} == "true" ]] && echo " - Tekton Triggers"
  [[ ${INSTALL_TEKTON_CHAINS} == "true" ]] && echo " - Tekton Chains"
  [[ ${INSTALL_TEKTON_DASHBOARD} == "true" ]] && echo " - Tekton Dashboard"
  [[ ${INSTALL_FORGE} == "true" ]] && echo " - Forgejo"
  [[ ${INSTALL_POSTGRESQL} == "true" ]] && echo " - PostgreSQL"
  [[ -n ${INSTALL_CUSTOM_OBJECT:-} && ${INSTALL_CUSTOM_OBJECT_ENABLED} == "true" ]] && echo " - Custom Objects"
  [[ ${INSTALL_GITHUB_SECOND_CTRL} == "true" ]] && echo " - GitHub Second Controller"
  echo ""
}

function parse_args() {
  # Pre-parse for --ci to set flag before check_tools()
  for arg in "$@"; do
    case "$arg" in
    --ci) CI_MODE="true" ;;
    esac
  done

  # Now check tools with correct CI_MODE value
  if ! check_tools; then
    exit 1
  fi

  # use getopt to parse arguments
  args=$(getopt \
    -o O:HASGsakhgc:ptFiR \
    --long \
    "all,
    show-config,
    all-but-kind,
    all-github-second-no-forgejo,
    all-to-tekton,
    configure-pac,
    deploy-component:,
    github-second-ctrl,
    help,
    install-custom-crds,
    install-dashboard,
    install-forge,
    install-nginx,
    install-paac,
    install-postgresql,
    install-registry,
    install-tekton,
    install-triggers,
    install-chains,
    stop-kind,
    redeploy-kind,
    second-secret:,
    start-user-gosmee,
    debug-image,
    configure-pac-target,
    all-but-forge,
    sync-kubeconfig,
    scale-down:,
    menu,
    interactive,
    reset-preferences,
    ci,
    kind
    " -- "$@")
  #shellcheck disable=SC2181
  if [ $? -ne 0 ]; then
    exit 1
  fi
  eval set -- "$args"
  while true; do
    case "$1" in
    -O | --scale-down) # scale down the controller
      scale_down_controller+=" $2"
      shift
      ;;

    -g | --install-forge) # Install Forgejo
      install_forgejo ${FORGE_HOST}
      exit
      ;;
    --debug-image) # use a debug image to apply KO images
      show_step "Using debug image:  ${PAC_DEBUG_IMAGE}"
      export KO_DEFAULTBASEIMAGE=${PAC_DEBUG_IMAGE}
      PAC_IMAGE_NONROOT=false
      install_pac
      echo
      echo "You can oc rsh to controller (or watcher, webhook) with:"
      echo "kubectl exec -it deployment/pipelines-as-code-controller -- bash"
      exit
      ;;
    --second-secret) # Set the secret for the second controller
      PAC_PASS_SECOND_FOLDER=$2
      shift
      install_github_second_ctrl
      exit
      ;;
    -s | --sync-kubeconfig) # Sync kubeconfig
      sync_kubeconfig
      exit
      ;;
    -S | --github-second-ctrl) # Deploy second controller for github
      install_github_second_ctrl
      exit
      ;;
    -H | --all-github-second-no-forgejo) # Install everything but forgejo
      INSTALL_FORGE=false
      install_kind
      all
      install_github_second_ctrl
      show_config
      exit
      ;;
    --show-config) # Show configuration
      show_config
      exit
      ;;
    -G | --start-user-gosmee) # Start gosmee locally for user $USER
      start_user_gosmee gosmee
      exit
      ;;
    -F | --all-but-forge) # Everything but forgejo
      INSTALL_FORGE=false
      all
      exit
      ;;
    --install-registry) # Install docker registry
      install_registry
      exit
      ;;
    --install-postgresql) # Install PostgreSQL
      install_postgresql
      exit
      ;;
    --install-dashboard) # Install Tekton dashboard
      install_dashboard
      exit
      ;;
    -t | --install-tekton) # Install Tekton
      install_tekton
      exit
      ;;
    --install-triggers) # Install Tekton triggers
      install_triggers
      exit
      ;;
    --install-chains) # Install Tekton chains
      install_chains
      exit
      ;;
    --install-nginx) # Install Nginx
      install_nginx
      exit
      ;;
    -a | --all) # Install everything
      install_kind
      all
      show_config
      exit
      ;;
    -A | --all-but-kind) # Install everything but kind
      all
      exit
      ;;
    --all-to-tekton) # Install everything up to Tekton
      install_kind
      sync_kubeconfig
      install_nginx
      install_registry
      install_tekton
      show_config
      exit
      ;;
    -c | --deploy-component) # Install a specific component
      install_pac "$2"
      shift
      exit
      ;;
    --install-custom-crds) # Install custom crds
      install_custom_crds
      exit
      ;;
    --configure-pac) # Configure PAC
      configure_pac
      exit
      ;;
    --configure-pac-target) # Configure PAC to a target, this won't configure a ingress
      # example: startpaac --configure-pac-target $KUBECONFIG openshift-pipelines /tmp/pac-secret
      export KUBECONFIG=$3
      export PAC_CONTROLLER_TARGET_NS=$4
      if [[ -d ~/.password-store/$5 ]]; then
        export PAC_PASS_SECRET_FOLDER=$5
        smee_url=$(pass show ${PAC_PASS_SECRET_FOLDER}/smee)
      elif [[ -d $5 ]]; then
        export PAC_SECRET_FOLDER=$5
        smee_url=$(cat ${PAC_SECRET_FOLDER}/smee)
      else
        echo "Cannot find $5 folder or ~/.password-store/$5 folder"
        exit 1
      fi
      configure_pac --no-ingress
      show_step "Creating gosmee service in namespace gosmee"
      makeGosmee gosmee ${smee_url} http://pipelines-as-code-controller.$PAC_CONTROLLER_TARGET_NS.svc.cluster.local:8080 gosmee
      exit
      ;;
    -p | --install-paac) # Deploy and configure PAC
      install_pac
      configure_pac
      exit
      ;;
    -k | --kind) # Install Kind
      install_kind
      sync_kubeconfig
      exit
      ;;
    --stop-kind) # Stop Kind
      stop_kind
      exit
      ;;
    --redeploy-kind) # Redeploy Kind
      stop_kind
      install_kind
      sync_kubeconfig
      exit
      ;;
    -i | --menu | --interactive) # Force interactive component selection menu
      FORCE_INTERACTIVE="true"
      ;;
    --ci) # Non-interactive CI mode (skips gum, uses TLS with minica)
      CI_MODE="true"
      FORCE_INTERACTIVE="false"
      ;;
    -R | --reset-preferences) # Reset saved component preferences
      reset_preferences
      exit 0
      ;;
    -h | --help) # Show help
      help
      exit 0
      ;;
    --)
      shift
      break
      ;;
    *)
      echo "Not implemented"
      help
      exit 1
      ;;
    esac
    shift
  done

  # No arguments given - interactive mode (or CI mode)
  show_config
  echo

  # In CI mode, skip all interactive prompts
  if [[ ${CI_MODE} == "true" ]]; then
    echo_color yellow "CI mode enabled - using defaults, skipping interactive prompts"
    # Use preferences if available, otherwise use defaults
    [[ -f ${PREFERENCES_FILE} ]] && load_preferences
    show_selected_components
    install_kind
    all
    show_config
    exit
  fi

  # Determine whether to show menu
  local show_menu=true

  if [[ -f ${PREFERENCES_FILE} && ${FORCE_INTERACTIVE} != "true" ]]; then
    show_menu=false
    load_preferences
    echo_color yellow "Using saved preferences from ${PREFERENCES_FILE}"
    echo_color yellow "Run with --menu to change, or --reset-preferences to clear."
  fi

  if [[ ${show_menu} == "true" ]]; then
    show_component_menu
    prompt_save_preferences
  fi

  show_selected_components

  # Final confirmation
  if ! gum confirm "Proceed with installation?"; then
    echo "Installation cancelled."
    exit 1
  fi

  install_kind
  all
  show_config
  exit
}

parse_args "$@"
